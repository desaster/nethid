#!/usr/bin/env python3
"""
Generate fsdata.c from web/dist for lwIP httpd embedded filesystem.

This creates a C file with all static web assets embedded as byte arrays,
suitable for serving via the lwIP HTTP server.
"""

import os
import sys
from pathlib import Path

# MIME type mapping
MIME_TYPES = {
    '.html': 'text/html',
    '.htm': 'text/html',
    '.css': 'text/css',
    '.js': 'application/javascript',
    '.json': 'application/json',
    '.png': 'image/png',
    '.jpg': 'image/jpeg',
    '.jpeg': 'image/jpeg',
    '.gif': 'image/gif',
    '.svg': 'image/svg+xml',
    '.ico': 'image/x-icon',
    '.woff': 'font/woff',
    '.woff2': 'font/woff2',
    '.txt': 'text/plain',
}


def get_mime_type(filename):
    ext = Path(filename).suffix.lower()
    return MIME_TYPES.get(ext, 'application/octet-stream')


def make_c_name(path):
    """Convert a path to a valid C identifier."""
    name = path.replace('/', '_').replace('.', '_').replace('-', '_')
    if name.startswith('_'):
        name = name[1:]
    return f"data__{name}"


def generate_http_header(path, content_length, mime_type):
    """Generate HTTP response header for a file."""
    header = f"HTTP/1.1 200 OK\r\n"
    header += f"Content-Length: {content_length}\r\n"
    header += f"Content-Type: {mime_type}\r\n"
    header += f"\r\n"
    return header.encode('ascii')


def bytes_to_c_array(data, indent=""):
    """Convert bytes to C hex array format."""
    lines = []
    for i in range(0, len(data), 16):
        chunk = data[i:i+16]
        hex_values = ','.join(f'0x{b:02x}' for b in chunk)
        lines.append(f"{indent}{hex_values},")
    return '\n'.join(lines)


def process_files(src_dir):
    """Collect all files from source directory."""
    files = []
    src_path = Path(src_dir)

    for filepath in sorted(src_path.rglob('*')):
        if filepath.is_file():
            rel_path = '/' + str(filepath.relative_to(src_path))
            with open(filepath, 'rb') as f:
                content = f.read()
            files.append({
                'path': rel_path,
                'content': content,
                'mime_type': get_mime_type(filepath.name),
            })

    return files


def generate_fsdata(files):
    """Generate the fsdata.c content."""
    output = []

    # Header
    output.append('/* Auto-generated by makefsdata.py - do not edit */')
    output.append('#include "lwip/apps/fs.h"')
    output.append('#include "lwip/def.h"')
    output.append('')
    output.append('#define file_NULL (struct fsdata_file *) NULL')
    output.append('')
    output.append('#ifndef FS_FILE_FLAGS_HEADER_INCLUDED')
    output.append('#define FS_FILE_FLAGS_HEADER_INCLUDED 1')
    output.append('#endif')
    output.append('#ifndef FS_FILE_FLAGS_HEADER_PERSISTENT')
    output.append('#define FS_FILE_FLAGS_HEADER_PERSISTENT 0')
    output.append('#endif')
    output.append('')

    # Generate data arrays for each file
    for f in files:
        c_name = make_c_name(f['path'])
        http_header = generate_http_header(f['path'], len(f['content']), f['mime_type'])

        # Path as null-terminated string, padded to 4-byte boundary
        path_bytes = f['path'].encode('ascii') + b'\x00'
        while len(path_bytes) % 4 != 0:
            path_bytes += b'\x00'

        # Combine: path + header + content
        full_data = path_bytes + http_header + f['content']
        header_offset = len(path_bytes)

        output.append(f'/* {f["path"]} */')
        output.append(f'static const unsigned char {c_name}[] = {{')
        output.append(bytes_to_c_array(full_data))
        output.append('};')
        output.append('')

        f['c_name'] = c_name
        f['header_offset'] = header_offset
        f['full_size'] = len(full_data)

    # Generate file structure linked list
    prev_file = 'file_NULL'
    for f in files:
        c_name = f['c_name']
        file_var = f'file_{c_name}'

        output.append(f'const struct fsdata_file {file_var}[] = {{ {{')
        output.append(f'    {prev_file},')
        output.append(f'    {c_name},')
        output.append(f'    {c_name} + {f["header_offset"]},')
        output.append(f'    sizeof({c_name}) - {f["header_offset"]},')
        output.append(f'    FS_FILE_FLAGS_HEADER_INCLUDED | FS_FILE_FLAGS_HEADER_PERSISTENT,')
        output.append('}};')
        output.append('')

        prev_file = file_var

    # Root and count
    if files:
        last_file = f'file_{files[-1]["c_name"]}'
        output.append(f'#define FS_ROOT {last_file}')
    else:
        output.append('#define FS_ROOT file_NULL')
    output.append(f'#define FS_NUMFILES {len(files)}')

    return '\n'.join(output)


def main():
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <src_dir> <output_file>")
        sys.exit(1)

    src_dir = sys.argv[1]
    output_file = sys.argv[2]

    if not os.path.isdir(src_dir):
        print(f"Error: Source directory '{src_dir}' does not exist")
        sys.exit(1)

    files = process_files(src_dir)
    print(f"Processing {len(files)} files from {src_dir}")

    for f in files:
        print(f"  {f['path']} ({len(f['content'])} bytes, {f['mime_type']})")

    fsdata = generate_fsdata(files)

    os.makedirs(os.path.dirname(output_file), exist_ok=True)
    with open(output_file, 'w') as f:
        f.write(fsdata)

    print(f"Generated {output_file}")


if __name__ == '__main__':
    main()
